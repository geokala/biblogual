#! /usr/bin/env python3
"""Generate pages for a static blog."""
from argparse import ArgumentParser
from datetime import datetime
from hashlib import sha256
from html import escape
import json
import os
import subprocess
import sys
from tempfile import mkdtemp
import typing
from typing_extensions import TypedDict

DISABLED_NAVBAR_LINK_ATTRS = \
    'style="cursor:default" class="text-muted navbar-brand"'
# pylint: disable=C0301
POST_TEMPLATE = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head profile="http://www.w3.org/2005/10/profile">
<title>{blog_title}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{first_post}" class="navbar-brand"><strong>{first}</strong></a>
<a id="prev-link" href="{prev_post}" {prev_attrs}><strong>{previous}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{blog_title}</strong></a>
<a id="next-link" href="{next_post}" {next_attrs}><strong>{next}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{latest}</strong></a>
</div>
<div class="container-fluid clearfix">
{section1}
{section2}
</div>
</body>
</html>'''
INDEX_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head profile="http://www.w3.org/2005/10/profile">
<title>{{blog_title}}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>{{first}}</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{previous}}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{{blog_title}}</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{next}}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{{latest}}</strong></a>
</div>
<div class="container-fluid clearfix">
{{year_links}}
</div>
</body>
</html>'''
YEAR_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head profile="http://www.w3.org/2005/10/profile">
<title>{{blog_title}} - {{year}}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>{{first}}</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{previous}}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{{blog_title}}</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{next}}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{{latest}}</strong></a>
</div>
<div class="container-fluid clearfix">
{{post_links1}}
{{post_links2}}
</div>
</body>
</html>'''
# pylint: enable=C0301

DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'
LANGUAGE_MAPPINGS = None
MOOD_EMOJI_MAPPINGS = {
    'happy': 'ðŸ™‚',
    'sad': 'ðŸ™',
    'thoughtful': 'ðŸ¤”',
    'grumpy': 'ðŸ˜ ',
}
EXPECTED_BOOTSTRAP_FILES = {
    'bootstrap.min.css': '4ffcc598ee6cff4692c1cea272cd8a2f195f6dec32473e94370d6cdcfa5fe601',  # pylint: disable=C0301
    'bootstrap-grid.min.css': '158cf68fff05fa7b67dab1734752e67e4d4dcf08a3bbb3e046d5cd9cbc3bd86b',  # pylint: disable=C0301
    'bootstrap-reboot.min.css': 'cd3d5950dfe3d62fda39a009a26977aeef162d133c4a264ae5812bfb5489c5b8',  # pylint: disable=C0301
}


class Section:  # pylint: disable=R0903
    """A section of a blog post."""
    def __init__(self,
                 section_data: dict,
                 date: datetime,
                 link_urls: typing.Optional[typing.List[str]]):
        _validate_section_data(section_data)
        self.title = escape(section_data['title'])
        self.text = escape(section_data['text'])
        self.mood = escape(section_data.get('mood', ''))
        self.language = section_data['language']
        self.flag = LANGUAGE_MAPPINGS[self.language].flag
        self.date = _get_date_string(date, self.language)
        self.links = []
        if link_urls:
            link_descriptions = [
                escape(desc) for desc in section_data.get('links', [])]
            if len(link_urls) != len(link_descriptions):
                raise InvalidSectionData(
                    'Sections must have as many link descriptions as there '
                    'are link urls.\n'
                    f'Link descriptions: {link_descriptions}'
                    f'Link urls: {link_urls}'
                )
            self.links = list(zip(link_urls, link_descriptions))

    def get_html(self) -> str:
        """Get this section's HTML."""
        mood_string = ''
        if self.mood:
            mood = LANGUAGE_MAPPINGS[self.language].mood
            mood_emoji_name_mapping = MOOD_NAME_MAPPINGS[self.language].get(
                self.mood)
            emoji = ''
            if mood_emoji_name_mapping:
                emoji = MOOD_EMOJI_MAPPINGS[mood_emoji_name_mapping] + ' '
            mood_string = f'<small>{mood}: {emoji}{self.mood}</small>\n'
        if self.links:
            links_text = '\n'.join(['Links:<br />'] + [
                f'<a href="{link}">{description}</a><br />'
                for link, description in self.links
            ] + ['<br />'])
        else:
            links_text = ''
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{self.flag}{self.title}</h2>\n'
            f'{mood_string}'
            f'<p>{self.text}</p>\n'
            f'{links_text}'
            f'<small>{self.date}</small>\n'
            '</div>'
        )


class Post:  # pylint: disable=R0903
    """A blog post."""
    def __init__(self,  # pylint: disable=R0913
                 sections: typing.List[Section],
                 html_filename: str,
                 date: datetime,
                 first_path: str,
                 next_path: typing.Optional[str],
                 prev_path: typing.Optional[str],
                 blog_title: str):
        self.sections = sections
        self.html_filename = html_filename
        self.first_path = first_path
        self.next_path = next_path or '#'
        self.prev_path = prev_path or '#'
        self.date = date
        self.blog_title = blog_title

    def get_html(self) -> str:
        """Get this post's HTML."""
        return POST_TEMPLATE.format(
            section1=self.sections[0].get_html(),
            section2=self.sections[1].get_html(),
            first_post=self.first_path,
            prev_post=self.prev_path,
            prev_attrs=_get_header_link_attrs(self.prev_path),
            next_post=self.next_path,
            next_attrs=_get_header_link_attrs(self.next_path),
            blog_title=self.blog_title,
            **get_navigation_link_text()
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Year:
    """An overview of a year of blog posts."""
    def __init__(self, year: int, posts: typing.List[Post], blog_title: str):
        self.year = year
        self.posts = posts
        self.html_filename = f'year_{self.year}.html'
        self.languages = sorted([
            section.language for section in posts[0].sections
        ])
        self.blog_title = blog_title

    def get_html(self) -> str:
        """Get this year's HTML."""
        return YEAR_TEMPLATE.format(
            year=self.year,
            first_post=self.posts[0].html_filename,
            post_links1=self._get_post_links_html(self.languages[0]),
            post_links2=self._get_post_links_html(self.languages[1]),
            blog_title=self.blog_title,
            **get_navigation_link_text()
        )

    def _get_post_links_html(self, language: str):
        """Get the HTML for the given language for this year."""
        months_html = [
            self._get_section_month_html(month, language)
            for month in range(1,13)
        ]
        months_html_string = '\n'.join([
            month_html for month_html in months_html if month_html
        ])
        posts_title = LANGUAGE_MAPPINGS[language].posts
        flag = LANGUAGE_MAPPINGS[language].flag
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{flag}{posts_title}</h2>\n'
            f'{months_html_string}\n'
            '</div>\n'
        )

    def _get_section_month_html(self, month: int, language: str):
        """Get the section HTML for a given month and language."""
        relevant_posts = [post
                          for post in self.posts if post.date.month == month]
        month_html = []
        if relevant_posts:
            month_string = MONTH_MAPPINGS[language][month]
            month_html.append(f'<h3>{month_string}</h3>')
        dates_and_titles = {}
        for post in relevant_posts:
            for section in post.sections:
                if section.language == language:
                    dates_and_titles[post.date] = (section.title, post)
                    break
        for date in sorted(dates_and_titles):
            title, post = dates_and_titles[date]
            date_string = _get_date_string(post.date, language)
            month_html.append(
                f'<a href="{post.html_filename}">{date_string} - {title}'
                '</a><br />')
        return '\n'.join(month_html)

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Index:
    """The top level index."""
    def __init__(self, years: typing.List[Year], first_path: str,
                 blog_title: str):
        self.first_path = first_path
        self.years = years
        self.html_filename = 'index.html'
        self.blog_title = blog_title

    def _get_year_links_html(self):
        """Get the links for each year of blog posts."""
        return '\n'.join([
            f'<a href="{year.html_filename}">{year.year}</a>'
            for year in self.years
        ])

    def get_html(self) -> str:
        """Get the index HTML."""
        return INDEX_TEMPLATE.format(
            first_post=self.first_path,
            year_links=self._get_year_links_html(),
            blog_title=self.blog_title,
            **get_navigation_link_text()
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for the index in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class InvalidSectionData(Exception):
    """Raised when attempting to generate a section from invalid data."""


class LangData(TypedDict):
    """The dict structure of language json files."""
    short_name: str
    name: str
    flag: str
    mood: str
    posts: str
    title_placeholder: str
    text_placeholder: str
    first: str
    previous: str
    next: str
    latest: str
    months: typing.List[str]
    moods: typing.Dict[str, str]


class SectionData(TypedDict):
    """The dict structure of a section as contained in the json file."""
    title: str
    links: typing.List[str]
    text: str
    language: str
    mood: typing.Optional[str]


class PostData(TypedDict):
    """The dict structure of post data as contained in the json files."""
    date: str
    links: typing.List[str]
    sections: typing.List[SectionData]


class BlogDetails(TypedDict):
    """The dict structure of the blog details."""
    title: str
    allow_robots: str


def get_navigation_link_text():
    """Get the link text for navigation."""
    return {
        nav_name: '/'.join([
            LANGUAGE_MAPPINGS[lang][nav_name].upper()
            for lang in sorted(LANGUAGE_MAPPINGS)
        ])
        for nav_name in ['first', 'previous', 'next', 'latest']
    }


def _get_date_string(date: datetime, language: str):
    """Get the stringified date for the given language."""
    month = MONTH_MAPPINGS[language][date.month]
    return f'{date.year} {month} {date.day}'


def _get_header_link_attrs(target):
    """Get the attributes to assign to a header link based on the target."""
    if target == '#':
        return DISABLED_NAVBAR_LINK_ATTRS
    return 'class="navbar-brand"'


def _validate_section_data(section_data: dict):
    """Generate a Section if given valid section data."""
    required_keys = ['title', 'text', 'language']
    optional_keys = ['mood', 'links']
    all_keys = required_keys + optional_keys

    errors = []

    if (
        any(key not in all_keys for key in section_data)
        or not all(key in section_data for key in required_keys)
    ):
        valid = ','.join(sorted(all_keys))
        req = ','.join(sorted(required_keys))
        contained = ','.join(sorted(section_data))
        errors.append(
            f'The section data may contain the following keys: {valid}\n'
            f'The section data must contain the following keys: {req}\n'
            f'The section contained: {contained}'
        )

    if section_data['language'] not in LANGUAGE_MAPPINGS:
        errors.append(
            'Language was {}, but must be one of: {}'.format(  # pylint: disable=C0209
                section_data['language'],
                ','.join(LANGUAGE_MAPPINGS.keys()),
            )
        )

    if errors:
        raise InvalidSectionData('\n'.join(errors))


class InvalidPostData(Exception):
    """Raised when the data for a post is not as expected."""


def _get_post_data_path(post_file: str, data_dir: str) -> str:
    path = os.path.join(data_dir, post_file)
    return path


def _get_post_html_filename(post_file: str) -> str:
    name = os.path.splitext(post_file)[0]
    return name + '.html'


class InvalidLangCount(Exception):
    """Raised when an invalid amount of languages is provided."""


class Language:  # pylint: disable=R0903
    """A language as used by the blog."""
    def __init__(self, lang_dict: LangData):
        self.short_name = lang_dict['short_name']
        self.flag = lang_dict['flag']
        self.words = {
            word: lang_dict[word]
            for word in ['name', 'mood', 'posts',
                         'first', 'previous', 'next', 'latest']
        }
        self.placeholders = {
            placeholder: lang_dict[f'{placeholder}_placeholder']
            for placeholder in ['title', 'text']
        }
        self.months = lang_dict['months']
        self.moods = lang_dict['moods']


def load_language_mappings(data_dir: str):
    """Load the language mappings into the global variable."""
    global LANGUAGE_MAPPINGS
    lang_dir = os.path.join(data_dir, 'langs')
    lang_files = os.listdir(lang_dir)

    lang_count = len(lang_files)
    if lang_count != 2:
        raise InvalidLangCount(
            f"Expected 2 languages in {lang_dir}, found {lang_count}.")

    LANGUAGE_MAPPINGS = {}
    for lang_file in langs:
        with open(os.path.join(lang_dir, lang_file),
                  encoding='utf-8') as lang_handle:
            lang_data = json.load(lang_file)
        LANGUAGE_MAPPINGS[lang_data['short_name']] = Language(lang_data)


def load_details(data_dir: str) -> BlogDetails:
    """Load extra details of the blog, e.g. the blog title."""
    details_path = os.path.join(data_dir, 'details.json')
    expected_keys = {'title', 'allow_robots'}
    with open(details_path, encoding='utf-8') as details_handle:
        data = json.load(details_handle)
    unknown_keys = ','.join(set(data).difference(expected_keys))
    if unknown_keys:
        sys.stderr.write(
            f'Unknown keys found in blog details: {unknown_keys}\n')
    return {
        'title': data['title'],
        'allow_robots': data['allow_robots'],
    }


def load_posts(data_dir: str, blog_details: BlogDetails) -> typing.List[Post]:
    """Load post data from a directory."""
    posts_dir = os.path.join(data_dir, 'posts')
    posts = []
    post_data_files = [
        file_name for file_name in os.listdir(posts_dir)
        if file_name != 'details.json'
    ]
    first_post = _get_post_html_filename(post_data_files[0])
    for idx, post_file in enumerate(post_data_files):
        post_data_path = _get_post_data_path(post_file, posts_dir)
        prev_post = None
        next_post = None
        if idx > 0:
            prev_post = _get_post_html_filename(post_data_files[idx - 1])
        if idx < (len(post_data_files) - 1):
            next_post = _get_post_html_filename(post_data_files[idx + 1])
        with open(post_data_path, encoding='utf-8') as post_handle:
            post_data = json.load(post_handle)
        date = datetime.strptime(post_data['date'], DATETIME_FORMAT)
        if len(post_data['sections']) != 2:
            raise InvalidPostData(
                f'2 sections were expected in {post_data_path}')
        try:
            posts.append(Post(
                sections=[
                    Section(s,
                            date=date,
                            link_urls=post_data.get('links'))
                    for s in sorted(post_data['sections'],
                                    key=lambda x: x['language'])
                ],
                first_path=first_post,
                next_path=next_post,
                prev_path=prev_post,
                html_filename=_get_post_html_filename(post_file),
                date=date,
                blog_title=blog_details['title'],
            ))
        except InvalidSectionData as err:
            raise InvalidPostData(  # pylint: disable=W0707
                f'Post contained invalid section data: {err}')
    return posts


class InvalidHTMLDir(Exception):
    """Raised when post update cannot be performed."""


def get_robots_content(blog_details: BlogDetails) -> str:
    """Get the content of the robots.txt"""
    disallow = '' if blog_details['allow_robots'] else '/'
    return f'User-agent: *\nDisallow: {disallow}\n'


def get_robots_path(html_dir: str) -> str:
    """Get the path of the robots.txt"""
    return os.path.join(html_dir, 'robots.txt')


def get_favicon_path(html_dir: str) -> str:
    """Get the path where the favicon is expected to exist."""
    return os.path.join(html_dir, 'favicon')


def update_file_if_needed(expected_content: str, path: str,
                          verbose: bool=False):
    """Update a file if the contents should be changed.
    Returns True if updated, False if not.
    """
    current_content = None
    if os.path.exists(path):
        with open(path, encoding='utf-8') as handle:
            current_content = handle.read()
    if current_content == expected_content:
        if verbose:
            print(f'{path} is up to date.')
        return False
    print(f'Updating {path}')
    with open(path, 'w', encoding='utf-8') as handle:
        handle.write(expected_content)
    return True


def build_years_pages(posts: typing.List[Post],
                      blog_details: BlogDetails) -> typing.List[Year]:
    """Build the Year pages."""
    year_posts: typing.Dict[int, typing.List[Post]] = {}
    for post in posts:
        year = post.date.year
        if year not in year_posts:
            year_posts[year]= []
        year_posts[year].append(post)
    return [Year(year=year, posts=posts, blog_title=blog_details['title'])
            for year, posts in year_posts.items()]


def update_posts(posts: typing.List[Post], html_dir: str,
                 blog_details: BlogDetails):
    """Add new posts and update any existing posts that need updating."""

    updated = 0
    for post in posts:
        html_content = post.get_html()
        html_path = post.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated += 1
    if updated:
        print(f'Updated {updated}/{len(posts)} posts.')

    if update_file_if_needed(
        posts[-1].get_html(),
        os.path.join(html_dir, 'latest.html'),
    ):
        print('Updated latest post.')

    updated_years = 0
    years = build_years_pages(posts, blog_details)
    for year in years:
        html_content = year.get_html()
        html_path = year.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated_years += 1
    if updated_years:
        print(f'Updated {updated_years}/{len(years)} year pages.')

    index = Index(years, first_path=posts[0].html_filename,
                  blog_title=blog_details['title'])
    if update_file_if_needed(index.get_html(), index.get_html_path(html_dir)):
        print('Updated index.')

    robots_content = get_robots_content(blog_details)
    if update_file_if_needed(robots_content, get_robots_path(html_dir)):
        print('Updated robots.txt')

    favicon_path = get_favicon_path(html_dir)
    if not os.path.exists(favicon_path):
        sys.stderr.write(
            f'WARNING: Favicon does not exist at {favicon_path}.\n'
            'Consider optionally editing and using the provided '
            'placeholder.\n')


def check_html_dir_valid(html_dir: str):
    """Check that the targeted HTML dir is valid."""
    print('Checking HTML dir exists')
    if not os.path.isdir(html_dir):
        raise InvalidHTMLDir(
            f'HTML destination dir does not exist: {html_dir}')

    print('Validating bootstrap files')
    bootstrap_path = os.path.join(html_dir, 'bootstrap')
    bootstrap_files = {}
    for bs_file in os.listdir(bootstrap_path):
        bs_path = os.path.join(bootstrap_path, bs_file)
        with open(bs_path, 'rb') as bs_handle:
            bootstrap_files[bs_file] = sha256(
                bs_handle.read()).hexdigest()
    if bootstrap_files != EXPECTED_BOOTSTRAP_FILES:
        raise InvalidHTMLDir(
            'Expected bootstrap files not found.\n'  # pylint: disable=C0209
            'Expected to see the following files with listed SHA256 hashes:\n'
            '{expected_output}\n'
            'The following files were seen:\n'
            '{seen_output}'.format(
                expected_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in EXPECTED_BOOTSTRAP_FILES.items()
                ),
                seen_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in bootstrap_files.items()
                ),
            )
        )


def get_user_confirmation(message='Are these correct? (y/n): ') -> bool:
    """Prompt the user to see if something is correct."""
    while True:
        confirm = input(message).strip().lower()
        if confirm == 'y':
            return True
        if confirm == 'n':
            return False
        print(f'{confirm} is not a valid response.')


def get_links() -> typing.List[typing.Dict[str, str]]:
    """Get links to add to the post, if any."""
    links: typing.List[typing.Dict[str, str]] = []
    add_prompt = 'Would you like to add a link? (y/n): '
    while True:
        if not get_user_confirmation(add_prompt):
            return links

        link = {}
        link['url'] = input('Enter link URL: ').strip()

        for lang in sorted(LANGUAGE_MAPPINGS):
            lang_name = LANGUAGE_MAPPINGS[lang]['name']
            link[lang] = input(
                f'Enter {lang_name} description for this URL: ')

        if get_user_confirmation('Is this URL correct? (y/n): '):
            links.append(link)


def get_custom_mood() -> typing.Tuple[str, str]:
    """Prompt the user for a custom mood."""
    moods = {lang: '' for lang in LANGUAGE_MAPPINGS}
    while any(not mood for mood in moods.values()):
        for lang in sorted(moods):
            lang_name = LANGUAGE_MAPPINGS[lang]['name']
            moods[lang] = input(f'Enter {lang_name} mood:').strip()
        if get_user_confirmation():
            moods = {lang: '' for lang in LANGUAGE_MAPPINGS}
    order = sorted(moods.keys())
    return moods[order[0]], moods[order[1]]


def get_mood() -> typing.Tuple[str, str]:
    """Prompt the user to get their mood."""
    moods = sorted(
        MOOD_NAME_MAPPINGS['dk'].items(),
        key=lambda x: x[0],
    )

    display_template = '{num}: {lang1} / {lang2}'

    selection = 0
    print('Select mood:')
    for num, mood in enumerate(moods):
        print(display_template.format(num, mood[0], mood[1]))
        print('{}: Custom'.format(len(moods)))  # pylint: disable=C0209
    while not selection:
        try:
            selection = int(input('Select mood: '))
        except ValueError:
            selection = 0

        if selection < 1 or selection > len(moods):
            selection = 0
        else:
            if selection == len(moods):
                return get_custom_mood()
    return moods[selection - 1]


def get_initial_section_data(tempdir: str) -> typing.List[SectionData]:
    """Get the text of the post sections from the user."""
    lang_paths = [
        os.path.join(tempdir, lang)
        for lang in sorted(LANGUAGE_MAPPINGS)
    ]
    file1, file2 = lang_paths

    for lang_file in lang_paths:
        lang_text = LANGUAGE_MAPPINGS[lang_file.split('/')[-1]]
        with open(lang_file, 'w', encoding='utf-8') as handle:
            handle.writelines([
                lang_text['title_placeholder'],
                lang_text['text_placeholder'],
            ])
    subprocess.call(f"vim {file1} -S <(echo 'vs {file2}')")

    sections: typing.List[SectionData] = [
        {
            'title': '',
            'links': [],
            'text': '',
            'language': lang,
            'mood': None,
        }
        for lang in sorted(LANGUAGE_MAPPINGS)
    ]

    for idx, lang_file in enumerate(lang_paths):
        lang = lang_file.split('/')[-1]
        with open(lang_file, 'r', encoding='utf-8') as handle:
            lang_content = handle.readlines()
        if sections[idx]['language'] != lang:
            raise RuntimeError(
                'Section language mismatch- this should never happen.'
            )
        sections[idx]['title'] = lang_content[0]
        sections[idx]['text'] = '\n'.join(lang_content[1:])
    return sections


def make_post(posts_path: str):
    """Make a new post"""
    new_post: PostData = {
        'date': datetime.now().strftime(DATETIME_FORMAT),
        'links': [],
        'sections': [],
    }

    tempdir = mkdtemp(prefix='blogpost')

    try:
        new_post['sections'] = get_initial_section_data(tempdir)
    finally:
        for temp_lang in os.listdir(tempdir):
            temp_lang_path = os.path.join(tempdir, temp_lang)
            os.unlink(temp_lang_path)
        os.rmdir(tempdir)

    mood = get_mood()
    new_post['sections'][0]['mood'] = mood[0]
    new_post['sections'][1]['mood'] = mood[1]

    links = get_links()
    for link in links:
        new_post['links'].append(link['url'])
        for section in new_post['sections']:
            section['links'].append(link[section['language']])

    date = new_post['date']
    post_num = 0
    suffix = 'json'
    post_file = f'{date}-{post_num}.{suffix}'
    while os.path.exists(post_file):
        post_num += 1
        post_file = f'{date}-{post_num}.{suffix}'

    with open(os.path.join(posts_path, post_file), 'w',
              encoding='utf-8') as post_handle:
        json.dump(new_post, post_handle)


def _main(args: typing.List[str]):
    parser = ArgumentParser(description='Biblogual management tool.')

    parser.add_argument(
        '-v', '--version',
        help='Display version information.',
        action='version',
        version='prerelease',
    )

    subparsers = parser.add_subparsers(
        help='Blog action', dest='action',
    )

    subparsers.add_parser('make_post', help='Make new blog post.')

    subparsers.add_parser(
        'reconcile',
        help='Bring posts into line with template/data changes.')

    args = parser.parse_args()

    source_dir = 'test_posts'
    dest_dir = 'test_html'
    try:
        load_language_mappings(source_dir)
    except InvalidLangCount as err:
        sys.stderr.write('%s\n' % err)
        sys.exit(1)

    if args.action == 'make_post':
        print('Make post')
    elif args.action == 'reconcile':
        blog_details = load_details(source_dir)
        posts_data = load_posts(source_dir, blog_details)
        check_html_dir_valid(dest_dir)
        update_posts(posts_data, dest_dir, blog_details)


if __name__ == '__main__':
    _main(sys.argv)
