#! /usr/bin/env python3
"""Generate pages for a static blog."""
# Don't alert on the file being too long, it's deliberately a single file app with no deps.
# pylint: disable=C0302
from argparse import ArgumentParser
from datetime import datetime
import getpass
from hashlib import sha256
from html import escape
import json
import os
import subprocess
import sys
from tempfile import mkdtemp
import typing
from typing import TypedDict

DISABLED_NAVBAR_LINK_ATTRS = \
    'style="cursor:default" class="text-muted navbar-brand"'
# pylint: disable=C0301
POST_TEMPLATE = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="{first_lang}">
<head profile="http://www.w3.org/2005/10/profile">
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<title>{blog_title}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{first_post}" class="navbar-brand"><strong>{first}</strong></a>
<a id="prev-link" href="{prev_post}" {prev_attrs}><strong>{previous}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{blog_title}</strong></a>
<a id="next-link" href="{next_post}" {next_attrs}><strong>{next}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{latest}</strong></a>
</div>
<div class="container-fluid clearfix">
{section1}
{section2}
</div>
</body>
</html>'''
INDEX_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="{{first_lang}}">
<head profile="http://www.w3.org/2005/10/profile">
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<title>{{blog_title}}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>{{first}}</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{previous}}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{{blog_title}}</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{next}}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{{latest}}</strong></a>
</div>
<div class="container-fluid clearfix">
{{year_links}}
</div>
</body>
</html>'''
YEAR_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="{{first_lang}}">
<head profile="http://www.w3.org/2005/10/profile">
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<title>{{blog_title}} - {{year}}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
<link rel="icon" 
      type="image/png" 
      href="favicon">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>{{first}}</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{previous}}</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>{{blog_title}}</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>{{next}}</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>{{latest}}</strong></a>
</div>
<div class="container-fluid clearfix">
{{post_links1}}
{{post_links2}}
</div>
</body>
</html>'''
# pylint: enable=C0301

DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'
MOOD_EMOJI_MAPPINGS = {
    'happy': '🙂',
    'sad': '🙁',
    'thoughtful': '🤔',
    'grumpy': '😠',
}
EXPECTED_BOOTSTRAP_FILES = {
    'bootstrap.min.css': '4ffcc598ee6cff4692c1cea272cd8a2f195f6dec32473e94370d6cdcfa5fe601',  # pylint: disable=C0301
    'bootstrap-grid.min.css': '158cf68fff05fa7b67dab1734752e67e4d4dcf08a3bbb3e046d5cd9cbc3bd86b',  # pylint: disable=C0301
    'bootstrap-reboot.min.css': 'cd3d5950dfe3d62fda39a009a26977aeef162d133c4a264ae5812bfb5489c5b8',  # pylint: disable=C0301
}
GITHUB_PATH = 'https://raw.githubusercontent.com/geokala/biblogual/main'


class LangData(TypedDict):
    """The dict structure of language json files."""
    short_name: str
    flag: str
    words: typing.Dict[str, str]
    placeholders: typing.Dict[str, str]
    months: typing.List[str]
    moods: typing.Dict[str, str]


class LanguageValidationError(Exception):
    """Raised when a loaded language json is invalid."""

class Language:  # pylint: disable=R0903
    """A language as used by the blog."""
    def __init__(self, lang_dict: LangData):
        self.short_name = lang_dict['short_name']
        self.flag = lang_dict['flag']
        self.words = lang_dict['words']
        self.placeholders = lang_dict['placeholders']
        self.months = {
            # So that we can lookup by the datetime's month number
            pos + 1: month
            for pos, month in enumerate(lang_dict['months'])
        }
        self.moods = lang_dict['moods']

        self._validate()

    def _validate(self):
        problems = []
        expected_words = {'name', 'mood', 'posts',
                          'first', 'previous', 'next', 'latest'}
        expected_placeholders = {'title', 'text'}

        if len(self.months) != 12:
            problems.append('Expected 12 months.')

        missing_words = self.words.keys() - expected_words
        if missing_words:
            problems.append(f'Missing word mappings: {missing_words}')
        unexpected_words = expected_words - self.words.keys()
        if unexpected_words:
            problems.append(f'Unexpected word mappings: {unexpected_words}')

        missing_placeholders = \
            self.placeholders.keys() - expected_placeholders
        if missing_placeholders:
            problems.append(f'Missing placeholders: {missing_placeholders}')
        unexpected_placeholders = \
            expected_placeholders - self.placeholders.keys()
        if unexpected_placeholders:
            problems.append(
                f'Unexpected placeholders: {unexpected_placeholders}')

        if problems:
            problem_output = '\n'.join(problems)
            raise LanguageValidationError(
                f"Problems found for {self.short_name}:\n{problem_output}")


class Section:  # pylint: disable=R0903,R0902
    """A section of a blog post."""
    def __init__(self,
                 section_data: dict,
                 date: datetime,
                 link_urls: typing.Optional[typing.List[str]],
                 language_mappings: typing.Dict[str, Language]):
        _validate_section_data(section_data, language_mappings)
        self.title = escape(section_data['title'])
        self.text = escape(section_data['text'])
        self.mood = escape(section_data.get('mood', ''))
        self.language = section_data['language']
        self.language_mappings = language_mappings
        self.flag = self.language_mappings[self.language].flag
        self.date = _get_date_string(date, self.language,
                                     self.language_mappings)
        self.links = []
        if link_urls:
            link_descriptions = [
                escape(desc) for desc in section_data.get('links', [])]
            if len(link_urls) != len(link_descriptions):
                raise InvalidSectionData(
                    'Sections must have as many link descriptions as there '
                    'are link urls.\n'
                    f'Link descriptions: {link_descriptions}'
                    f'Link urls: {link_urls}'
                )
            self.links = list(zip(link_urls, link_descriptions))

    def get_html(self) -> str:
        """Get this section's HTML."""
        mood_string = ''
        if self.mood:
            mood = self.language_mappings[self.language].words['mood']
            mood_emoji_name_mapping = self.language_mappings[
                self.language].moods.get(self.mood)
            emoji = ''
            if mood_emoji_name_mapping:
                emoji = MOOD_EMOJI_MAPPINGS[mood_emoji_name_mapping] + ' '
            mood_string = f'<small>{mood}: {emoji}{self.mood}</small>\n'
        if self.links:
            links_text = '\n'.join(['Links:<br />'] + [
                f'<a href="{link}">{description}</a><br />'
                for link, description in self.links
            ] + ['<br />'])
        else:
            links_text = ''
        return (
            f'<div class="ml-5 float-md-left" lang="{self.language}">\n'
            f'<h2>{self.flag}{self.title}</h2>\n'
            f'{mood_string}'
            f'<p>{self.text}</p>\n'
            f'{links_text}'
            f'<small>{self.date}</small>\n'
            '</div>'
        )


class Post:  # pylint: disable=R0903,R0902
    """A blog post."""
    def __init__(self,  # pylint: disable=R0913
                 sections: typing.List[Section],
                 html_filename: str,
                 date: datetime,
                 first_path: str,
                 next_path: typing.Optional[str],
                 prev_path: typing.Optional[str],
                 blog_title: str,
                 language_mappings: typing.Dict[str, Language]):
        self.sections = sections
        self.html_filename = html_filename
        self.first_path = first_path
        self.next_path = next_path or '#'
        self.prev_path = prev_path or '#'
        self.date = date
        self.blog_title = blog_title
        self.language_mappings = language_mappings

    def get_html(self) -> str:
        """Get this post's HTML."""
        return POST_TEMPLATE.format(
            section1=self.sections[0].get_html(),
            section2=self.sections[1].get_html(),
            first_post=self.first_path,
            prev_post=self.prev_path,
            prev_attrs=_get_header_link_attrs(self.prev_path),
            next_post=self.next_path,
            next_attrs=_get_header_link_attrs(self.next_path),
            blog_title=self.blog_title,
            first_lang=sorted(self.language_mappings)[0],
            **get_navigation_link_text(self.language_mappings)
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Year:
    """An overview of a year of blog posts."""
    def __init__(self, year: int, posts: typing.List[Post], blog_title: str,
                 language_mappings: typing.Dict[str, Language]):
        self.year = year
        self.posts = posts
        self.html_filename = f'year_{self.year}.html'
        self.languages = sorted([
            section.language for section in posts[0].sections
        ])
        self.blog_title = blog_title
        self.language_mappings = language_mappings

    def get_html(self) -> str:
        """Get this year's HTML."""
        return YEAR_TEMPLATE.format(
            year=self.year,
            first_post=self.posts[0].html_filename,
            post_links1=self._get_post_links_html(self.languages[0]),
            post_links2=self._get_post_links_html(self.languages[1]),
            blog_title=self.blog_title,
            first_lang=sorted(self.language_mappings)[0],
            **get_navigation_link_text(self.language_mappings)
        )

    def _get_post_links_html(self, language: str):
        """Get the HTML for the given language for this year."""
        months_html = [
            self._get_section_month_html(month, language)
            for month in range(1,13)
        ]
        months_html_string = '\n'.join([
            month_html for month_html in months_html if month_html
        ])
        posts_title = self.language_mappings[language].words['posts']
        flag = self.language_mappings[language].flag
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{flag}{posts_title}</h2>\n'
            f'{months_html_string}\n'
            '</div>\n'
        )

    def _get_section_month_html(self, month: int, language: str):
        """Get the section HTML for a given month and language."""
        relevant_posts = [post
                          for post in self.posts if post.date.month == month]
        month_html = []
        if relevant_posts:
            month_string = self.language_mappings[language].months[month][:3]
            month_html.append(f'<h3>{month_string}</h3>')
        dates_and_titles = {}
        for post in relevant_posts:
            for section in post.sections:
                if section.language == language:
                    dates_and_titles[post.date] = (section.title, post)
                    break
        for date in sorted(dates_and_titles):
            title, post = dates_and_titles[date]
            date_string = _get_date_string(post.date, language,
                                           self.language_mappings)
            month_html.append(
                f'<a href="{post.html_filename}">{date_string} - {title}'
                '</a><br />')
        return '\n'.join(month_html)

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Index:
    """The top level index."""
    def __init__(self, years: typing.List[Year], first_path: str,
                 blog_title: str,
                 language_mappings: typing.Dict[str, Language]):
        self.first_path = first_path
        self.years = years
        self.html_filename = 'index.html'
        self.blog_title = blog_title
        self.language_mappings = language_mappings

    def _get_year_links_html(self):
        """Get the links for each year of blog posts."""
        return '\n'.join([
            f'<a href="{year.html_filename}">{year.year}</a>'
            for year in self.years
        ])

    def get_html(self) -> str:
        """Get the index HTML."""
        return INDEX_TEMPLATE.format(
            first_post=self.first_path,
            year_links=self._get_year_links_html(),
            blog_title=self.blog_title,
            first_lang=sorted(self.language_mappings)[0],
            **get_navigation_link_text(self.language_mappings)
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for the index in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class InvalidSectionData(Exception):
    """Raised when attempting to generate a section from invalid data."""


class SectionData(TypedDict):
    """The dict structure of a section as contained in the json file."""
    title: str
    links: typing.List[str]
    text: str
    language: str
    mood: typing.Optional[str]


class PostData(TypedDict):
    """The dict structure of post data as contained in the json files."""
    date: str
    links: typing.List[str]
    sections: typing.List[SectionData]


class InvalidDetails(Exception):
    """Raised when blog details are not correctly set."""


class BlogDetails(TypedDict):
    """The dict structure of the blog details."""
    title: str
    allow_robots: typing.Optional[bool]


def get_navigation_link_text(language_mappings):
    """Get the link text for navigation."""
    links = {}
    for nav_name in ['first', 'previous', 'next', 'latest']:
        nav_parts = []
        for lang in sorted(language_mappings):
            text = language_mappings[lang].words[nav_name].upper()
            nav_parts.append(f'<span lang="{lang}">{text}</span>')
        links[nav_name] = '/'.join(nav_parts)
    return links


def _get_date_string(date: datetime, language: str,
                     language_mappings: typing.Dict[str, Language]):
    """Get the stringified date for the given language."""
    month = language_mappings[language].months[date.month][:3]
    return f'{date.year} {month} {date.day}'


def _get_header_link_attrs(target):
    """Get the attributes to assign to a header link based on the target."""
    if target == '#':
        return DISABLED_NAVBAR_LINK_ATTRS
    return 'class="navbar-brand"'


def _validate_section_data(section_data: dict,
                           language_mappings: typing.Dict[str, Language]):
    """Generate a Section if given valid section data."""
    required_keys = ['title', 'text', 'language']
    optional_keys = ['mood', 'links']
    all_keys = required_keys + optional_keys

    errors = []

    if (
        any(key not in all_keys for key in section_data)
        or not all(key in section_data for key in required_keys)
    ):
        valid = ','.join(sorted(all_keys))
        req = ','.join(sorted(required_keys))
        contained = ','.join(sorted(section_data))
        errors.append(
            f'The section data may contain the following keys: {valid}\n'
            f'The section data must contain the following keys: {req}\n'
            f'The section contained: {contained}'
        )

    if section_data['language'] not in language_mappings:
        errors.append(
            'Language was {}, but must be one of: {}'.format(  # pylint: disable=C0209
                section_data['language'],
                ','.join(language_mappings.keys()),
            )
        )

    if errors:
        raise InvalidSectionData('\n'.join(errors))


class InvalidPostData(Exception):
    """Raised when the data for a post is not as expected."""


def _get_post_data_path(post_file: str, profile_dir: str) -> str:
    path = os.path.join(profile_dir, post_file)
    return path


def _get_post_html_filename(post_file: str) -> str:
    name = os.path.splitext(post_file)[0]
    return name + '.html'


def _get_language_path(profile_dir: str) -> str:
    return os.path.join(profile_dir, 'langs')


def _get_posts_path(profile_dir: str) -> str:
    return os.path.join(profile_dir, 'posts')


class InvalidLangCount(Exception):
    """Raised when an invalid amount of languages is provided."""


def load_language_mappings(profile_dir: str) -> typing.Dict[str, Language]:
    """Load the language mappings into the global variable."""
    lang_dir = _get_language_path(profile_dir)
    lang_files = os.listdir(lang_dir)

    language_mappings = {}
    for lang_file in lang_files:
        with open(os.path.join(lang_dir, lang_file),
                  encoding='utf-8') as lang_handle:
            lang_data = json.load(lang_handle)
        language_mappings[lang_data['short_name']] = Language(lang_data)
    return language_mappings


def _get_details_path(profile_dir: str) -> str:
    return os.path.join(profile_dir, 'details.json')


class InvalidBlogTitle(Exception):
    """Raised when attempting to set an invalid value for the blog title."""


def load_details(profile_dir: str, allow_missing: bool=False) -> BlogDetails:
    """Load extra details of the blog, e.g. the blog title."""
    details_path = _get_details_path(profile_dir)
    expected_keys = {'title', 'allow_robots'}
    data: BlogDetails = {'title': '', 'allow_robots': None}
    try:
        with open(details_path, encoding='utf-8') as details_handle:
            data.update(json.load(details_handle))
    except FileNotFoundError:
        if not allow_missing:
            raise
    unknown_keys = ','.join(set(data).difference(expected_keys))
    if unknown_keys:
        sys.stderr.write(
            f'Unknown keys found in blog details: {unknown_keys}\n')
    if not allow_missing:
        missing_keys = ','.join([key for key in ['title', 'allow_robots']
                                 if key not in data])
        if missing_keys:
            raise InvalidDetails(
                f'Keys missing from details: {missing_keys}')
    return data


def set_blog_title(profile_dir: str, title: str):
    """Update the details, setting the title of the blog."""
    if not title:
        raise InvalidBlogTitle("The blog title must not be empty.")
    details = load_details(profile_dir, allow_missing=True)
    details['title'] = title
    with open(_get_details_path(profile_dir), 'w',
              encoding='utf-8') as details_handle:
        json.dump(details, details_handle)


def set_robots_allowed(profile_dir: str, allow: str):
    """Update the details, allowing or disallowing robots."""
    details = load_details(profile_dir, allow_missing=True)
    details['allow_robots'] = allow == 'allow'
    with open(_get_details_path(profile_dir), 'w',
              encoding='utf-8') as details_handle:
        json.dump(details, details_handle)



def load_posts(  # pylint: disable=R0914
    profile_dir: str, blog_details: BlogDetails,
    language_mappings: typing.Dict[str, Language],
) -> typing.List[Post]:
    """Load post data from a directory."""
    posts_dir = _get_posts_path(profile_dir)
    posts = []
    post_data_files = [
        file_name for file_name in os.listdir(posts_dir)
        if file_name != 'details.json'
    ]
    first_post = _get_post_html_filename(post_data_files[0])
    for idx, post_file in enumerate(post_data_files):
        post_data_path = _get_post_data_path(post_file, posts_dir)
        prev_post = None
        next_post = None
        if idx > 0:
            prev_post = _get_post_html_filename(post_data_files[idx - 1])
        if idx < (len(post_data_files) - 1):
            next_post = _get_post_html_filename(post_data_files[idx + 1])
        with open(post_data_path, encoding='utf-8') as post_handle:
            post_data = json.load(post_handle)
        date = datetime.strptime(post_data['date'], DATETIME_FORMAT)
        if len(post_data['sections']) != 2:
            raise InvalidPostData(
                f'2 sections were expected in {post_data_path}')
        try:
            posts.append(Post(
                sections=[
                    Section(s,
                            date=date,
                            link_urls=post_data.get('links'),
                            language_mappings=language_mappings)
                    for s in sorted(post_data['sections'],
                                    key=lambda x: x['language'])
                ],
                first_path=first_post,
                next_path=next_post,
                prev_path=prev_post,
                html_filename=_get_post_html_filename(post_file),
                date=date,
                blog_title=blog_details['title'],
                language_mappings=language_mappings,
            ))
        except InvalidSectionData as err:
            raise InvalidPostData(  # pylint: disable=W0707
                f'Post contained invalid section data: {err}')
    return posts


class InvalidHTMLDir(Exception):
    """Raised when post update cannot be performed."""


def get_robots_content(blog_details: BlogDetails) -> str:
    """Get the content of the robots.txt"""
    disallow = '' if blog_details['allow_robots'] else '/'
    return f'User-agent: *\nDisallow: {disallow}\n'


def get_robots_path(html_dir: str) -> str:
    """Get the path of the robots.txt"""
    return os.path.join(html_dir, 'robots.txt')


def get_favicon_path(html_dir: str) -> str:
    """Get the path where the favicon is expected to exist."""
    return os.path.join(html_dir, 'favicon')


def update_file_if_needed(expected_content: str, path: str,
                          verbose: bool=False):
    """Update a file if the contents should be changed.
    Returns True if updated, False if not.
    """
    current_content = None
    if os.path.exists(path):
        with open(path, encoding='utf-8') as handle:
            current_content = handle.read()
    if current_content == expected_content:
        if verbose:
            print(f'{path} is up to date.')
        return False
    print(f'Updating {path}')
    with open(path, 'w', encoding='utf-8') as handle:
        handle.write(expected_content)
    return True


def build_years_pages(posts: typing.List[Post],
                      language_mappings: typing.Dict[str, Language],
                      blog_details: BlogDetails) -> typing.List[Year]:
    """Build the Year pages."""
    year_posts: typing.Dict[int, typing.List[Post]] = {}
    for post in posts:
        year = post.date.year
        if year not in year_posts:
            year_posts[year]= []
        year_posts[year].append(post)
    return [Year(year=year, posts=posts, blog_title=blog_details['title'],
                 language_mappings=language_mappings)
            for year, posts in year_posts.items()]


def update_posts(posts: typing.List[Post], html_dir: str,
                 blog_details: BlogDetails,
                 language_mappings: typing.Dict[str, Language]):
    """Add new posts and update any existing posts that need updating."""

    updated = 0
    for post in posts:
        html_content = post.get_html()
        html_path = post.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated += 1
    if updated:
        print(f'Updated {updated}/{len(posts)} posts.')

    if update_file_if_needed(
        posts[-1].get_html(),
        os.path.join(html_dir, 'latest.html'),
    ):
        print('Updated latest post.')

    updated_years = 0
    years = build_years_pages(posts, language_mappings, blog_details)
    for year in years:
        html_content = year.get_html()
        html_path = year.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated_years += 1
    if updated_years:
        print(f'Updated {updated_years}/{len(years)} year pages.')

    index = Index(years, first_path=posts[0].html_filename,
                  blog_title=blog_details['title'],
                  language_mappings=language_mappings)
    if update_file_if_needed(index.get_html(), index.get_html_path(html_dir)):
        print('Updated index.')

    robots_content = get_robots_content(blog_details)
    if update_file_if_needed(robots_content, get_robots_path(html_dir)):
        print('Updated robots.txt')


def _check_html_dir_exists(html_dir: str):
    user = getpass.getuser()
    dirs_to_existing = [html_dir]
    check_dir = os.path.dirname(html_dir)
    while True:
        if os.path.exists(check_dir):
            break
        dirs_to_existing.append(check_dir)
        check_dir = os.path.dirname(check_dir)

    base_ownership = 'root.www'
    blog_dir_ownership = f'{user}.www'
    # Needs exec bit to allow traversing to subfolders
    perms = '751'

    if dirs_to_existing:
        dirs_to_existing.reverse()

        dir_commands = f'''\nThe base directories can be set up with:
doas ksh -c 'mkdir -p {html_dir}/\n'''

        base_not_existing = dirs_to_existing[0]
        dir_commands += f'chmod -R {perms} {base_not_existing}\n'
        if len(dirs_to_existing) > 1:
            dir_commands += f'chown -R {base_ownership} {base_not_existing}\n'
        dir_commands += f"chown -R {blog_dir_ownership} {html_dir}'\n"

    print('Checking HTML dir exists')
    if not os.path.isdir(html_dir):
        raise InvalidHTMLDir(
            f'HTML destination dir does not exist: {html_dir}\n'
            f'{dir_commands}')


def _check_bootstrap_files(html_dir: str):  # pylint: disable=R0914
    print('Validating bootstrap files')
    bootstrap_path = os.path.join(html_dir, 'bootstrap')
    bootstrap_files = {}
    try:
        existing_files = os.listdir(bootstrap_path)
    except FileNotFoundError:
        # The dir does not exist, so clearly there are no files
        existing_files = []
    for bs_file in existing_files:
        bs_path = os.path.join(bootstrap_path, bs_file)
        with open(bs_path, 'rb') as bs_handle:
            bootstrap_files[bs_file] = sha256(
                bs_handle.read()).hexdigest()

    if bootstrap_files != EXPECTED_BOOTSTRAP_FILES:
        bs_commands = f'''\nThe bootstrap files can be set up with:
mkdir -p {bootstrap_path}\n'''
        repo_bs_path = 'test_html/bootstrap'
        for bs_file, expected_hash in EXPECTED_BOOTSTRAP_FILES.items():
            existing = bootstrap_files.get(bs_file)
            if existing != expected_hash:
                dest_path = os.path.join(bootstrap_path, bs_file)
                local_path = os.path.join(repo_bs_path, bs_file)
                bs_commands += _get_cp_or_curl(local_path, dest_path)
        bs_commands = bs_commands.rstrip()

        expected_output='\n'.join(
            ' '.join(fn_hash)
            for fn_hash in EXPECTED_BOOTSTRAP_FILES.items()
        )
        seen_output='The following files were seen:\n' + '\n'.join(
            ' '.join(fn_hash)
            for fn_hash in bootstrap_files.items()
        ) if bootstrap_files else 'No files were seen.'
        raise InvalidHTMLDir(
            'Expected bootstrap files not found.\n'  # pylint: disable=C0209
            'Expected to see the following files with listed SHA256 hashes:\n'
            f'{expected_output}\n'
            f'{seen_output}\n'
            f'{bs_commands}'
        )


def _check_favicon(html_dir: str):
    print('Checking favicon')
    favicon_path = get_favicon_path(html_dir)
    if not os.path.exists(favicon_path):
        command = _get_cp_or_curl('placeholder_favicon.jpg', favicon_path)
        sys.stderr.write(
            f'WARNING: Favicon does not exist at {favicon_path}.\n'
            'Consider optionally editing and using the provided '
            'placeholder.\n'
            f'You can copy the placeholder with:\n{command}'
        )


def _get_cp_or_curl(source_path: str, dest_path: str):
    exc_path = os.path.dirname(__file__)
    local_source = os.path.join(exc_path, source_path)
    if os.path.exists(local_source):
        return f'cp {local_source} {dest_path}\n'
    remote_source = os.path.join(GITHUB_PATH, source_path)
    return f'curl -o {dest_path} {remote_source}\n'


def check_html_dir_valid(html_dir: str):
    """Check that the targeted HTML dir is valid."""
    _check_html_dir_exists(html_dir)
    _check_bootstrap_files(html_dir)
    _check_favicon(html_dir)


def check_language_mappings(profile_dir: str):
    """Check that two language mappings are present."""
    lang_dir = _get_language_path(profile_dir)
    lang_files = os.listdir(lang_dir)

    lang_count = len(lang_files)
    if lang_count != 2:
        repo_langs = ['dk', 'en']

        get_helps = ''
        repo_base = 'test_posts/langs'
        for lang in repo_langs:
            lang_path = os.path.join(repo_base, lang + '.json')
            dest_path = os.path.join(profile_dir, 'langs', lang + '.json')
            get_helps += _get_cp_or_curl(lang_path, dest_path)

        raise InvalidLangCount(
            f"Expected 2 languages in {lang_dir}, found {lang_count}.\n"
            "To use languages from the repo, run two of the following:\n"
            f"{get_helps}")


def check_details(profile_dir: str):
    """Check that the extra details are set correctly in the profile."""
    details_path = _get_details_path(profile_dir)
    prog = sys.argv[0]
    set_title = f'"{prog} set_title"'
    set_robots = f'"{prog} set_robots <allow|disallow>"'
    if not os.path.exists(details_path):
        data: BlogDetails = {'title': '', 'allow_robots': None}

        raise InvalidDetails(
            'Blog details are not configured.\n'
            f'Run {set_title} or {set_robots}'
        )
    data = load_details(profile_dir, allow_missing=True)
    problems = []
    if not data['title']:
        problems.append(f'Title not set. Run {set_title}')
    if data['allow_robots'] is None:
        problems.append(f'Robot permissions not set. Run {set_robots}')
    if problems:
        raise InvalidDetails('\n'.join(problems))


def get_user_confirmation(message='Are these correct? (y/n): ') -> bool:
    """Prompt the user to see if something is correct."""
    while True:
        confirm = input(message).strip().lower()
        if confirm == 'y':
            return True
        if confirm == 'n':
            return False
        print(f'{confirm} is not a valid response.')


def get_links(language_mappings: typing.Dict[str, Language]
              ) -> typing.List[typing.Dict[str, str]]:
    """Get links to add to the post, if any."""
    links: typing.List[typing.Dict[str, str]] = []
    add_prompt = 'Would you like to add a link? (y/n): '
    while True:
        if not get_user_confirmation(add_prompt):
            return links

        link = {}
        link['url'] = input('Enter link URL: ').strip()

        for lang in sorted(language_mappings):
            lang_name = language_mappings[lang].words['name']
            link[lang] = input(
                f'Enter {lang_name} description for this URL: ')

        if get_user_confirmation('Is this URL correct? (y/n): '):
            links.append(link)


def get_custom_mood(language_mappings: typing.Dict[str, Language]
                    ) -> typing.Tuple[str, str]:
    """Prompt the user for a custom mood."""
    moods = {lang: '' for lang in language_mappings}
    while any(not mood for mood in moods.values()):
        for lang in sorted(moods):
            lang_name = language_mappings[lang].words['name']
            moods[lang] = input(f'Enter {lang_name} mood:').strip()
        if not get_user_confirmation():
            moods = {lang: '' for lang in language_mappings}
    order = sorted(moods.keys())
    return moods[order[0]], moods[order[1]]


def get_mood(language_mappings: typing.Dict[str, Language]
             ) -> typing.Tuple[str, str]:
    """Prompt the user to get their mood."""
    moods = sorted(
        language_mappings['dk'].moods.items(),
        key=lambda x: x[0],
    )

    display_template = '{num}: {lang1} / {lang2}'

    selection = 0
    print('Select mood:')
    for num, mood in enumerate(moods):
        print(display_template.format(num=num,
                                      lang1=mood[0],
                                      lang2=mood[1]))
    print('{}: Custom'.format(len(moods)))  # pylint: disable=C0209
    while not selection:
        try:
            selection = int(input('Select mood: '))
        except ValueError:
            selection = 0

        if selection < 1 or selection > len(moods):
            selection = 0
        else:
            if selection == len(moods):
                return get_custom_mood(language_mappings)
    return moods[selection - 1]


def get_initial_section_data(tempdir: str,
                             language_mappings: typing.Dict[str, Language],
                             ) -> typing.List[SectionData]:
    """Get the text of the post sections from the user."""
    lang_paths = [
        os.path.join(tempdir, lang)
        for lang in sorted(language_mappings)
    ]
    file1, file2 = lang_paths

    for lang_file in lang_paths:
        lang_text = language_mappings[
            lang_file.split('/')[-1]].placeholders
        with open(lang_file, 'w', encoding='utf-8') as handle:
            handle.writelines([
                lang_text['title'] + '\n',
                lang_text['text'] + '\n',
            ])
    vim_script_path = os.path.join(tempdir, 'sidebyside')
    with open(vim_script_path, 'w', encoding='utf-8') as vim_script_handle:
        vim_script_handle.write(f'vs {file2}')
    subprocess.call(["vim", file1, "-S", vim_script_path])

    sections: typing.List[SectionData] = [
        {
            'title': '',
            'links': [],
            'text': '',
            'language': lang,
            'mood': None,
        }
        for lang in sorted(language_mappings)
    ]

    for idx, lang_file in enumerate(lang_paths):
        lang = lang_file.split('/')[-1]
        with open(lang_file, 'r', encoding='utf-8') as handle:
            lang_content = handle.readlines()
        if sections[idx]['language'] != lang:
            raise RuntimeError(
                'Section language mismatch- this should never happen.'
            )
        sections[idx]['title'] = lang_content[0]
        sections[idx]['text'] = '\n'.join(lang_content[1:])
    return sections


def make_post(profile_dir: str, dest_dir: str,  # pylint: disable=R0914
              language_mappings: typing.Dict[str, Language]):
    """Make a new post"""
    new_post: PostData = {
        'date': datetime.now().strftime(DATETIME_FORMAT),
        'links': [],
        'sections': [],
    }

    tempdir = mkdtemp(prefix='blogpost')

    try:
        new_post['sections'] = get_initial_section_data(
            tempdir, language_mappings,
        )
    finally:
        for temp_lang in os.listdir(tempdir):
            temp_lang_path = os.path.join(tempdir, temp_lang)
            os.unlink(temp_lang_path)
        os.rmdir(tempdir)

    mood = get_mood(language_mappings)
    new_post['sections'][0]['mood'] = mood[0]
    new_post['sections'][1]['mood'] = mood[1]

    links = get_links(language_mappings)
    for link in links:
        new_post['links'].append(link['url'])
        for section in new_post['sections']:
            section['links'].append(link[section['language']])

    date = new_post['date']
    post_num = 0
    suffix = 'json'
    post_file = f'{date}-{post_num}.{suffix}'
    while os.path.exists(post_file):
        post_num += 1
        post_file = f'{date}-{post_num}.{suffix}'

    with open(os.path.join(_get_posts_path(profile_dir), post_file), 'w',
              encoding='utf-8') as post_handle:
        json.dump(new_post, post_handle)
    reconcile(profile_dir, dest_dir, language_mappings)


def reconcile(profile_dir: str, dest_dir: str,
              language_mappings: typing.Dict[str, Language]):
    """Ensure the current html matches the defined posts/etc."""
    check_details(profile_dir)
    blog_details = load_details(profile_dir)
    posts_data = load_posts(profile_dir, blog_details, language_mappings)
    check_html_dir_valid(profile_dir)
    update_posts(posts_data, dest_dir, blog_details, language_mappings)


def _main(args: typing.List[str]):
    parser = ArgumentParser(description='Biblogual management tool.')

    parser.add_argument(
        '-v', '--version',
        help='Display version information.',
        action='version',
        version='prerelease',
    )

    subparsers = parser.add_subparsers(
        help='Blog action', dest='action',
    )

    subparsers.add_parser('make_post', help='Make new blog post.')

    subparsers.add_parser(
        'reconcile',
        help='Bring posts into line with template/data changes.')

    set_title = subparsers.add_parser('set_title',
                                      help="Set the blog's title.")
    set_title.add_argument('title')

    set_robots = subparsers.add_parser('set_robots',
                                       help='Allow or disallow web crawlers.')
    set_robots.add_argument('allow', choices=['allow', 'disallow'])

    parsed_args = parser.parse_args(args[1:])

    profile_dir = os.path.expanduser('~/.biblogual')
    if not os.path.exists(profile_dir):
        os.makedirs(profile_dir, mode=0o700)
        os.makedirs(_get_language_path(profile_dir), mode=0o700)
        os.makedirs(_get_posts_path(profile_dir), mode=0o700)
    dest_dir = f'/var/www/htdocs/default/blog/{getpass.getuser()}'

    check_language_mappings(profile_dir)

    try:
        language_mappings = load_language_mappings(profile_dir)
    except InvalidLangCount as err:
        sys.stderr.write(f'{err}\n')
        sys.exit(1)

    if parsed_args.action == 'make_post':
        make_post(profile_dir, dest_dir, language_mappings)
    elif parsed_args.action == 'reconcile':
        reconcile(profile_dir, dest_dir, language_mappings)
    elif parsed_args.action == 'set_title':
        set_blog_title(profile_dir, parsed_args.title)
    elif parsed_args.action == 'set_robots':
        set_robots_allowed(profile_dir, parsed_args.allow)

if __name__ == '__main__':
    _main(sys.argv)
