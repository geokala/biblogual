#! /usr/bin/env python3
"""Generate pages for a static blog."""
from hashlib import sha256
from html import escape
import json
import os
import typing

# pylint: disable=C0301
POST_TEMPLATE = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BLOG TITLE</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="home-link" href="{prev_post}" {prev_attrs}><strong>PREVIOUS POST</strong></a>
<a id="home-link" href="{next_post}" {next_attrs}><strong>NEXT POST</strong></a>
<a id="home-link" href="/" class="navbar-brand"><strong>HOMEPAGE</strong></a>
</div>
<div class="container-fluid clearfix">
{section1}
{section2}
</div>
</body>
</html>'''
# pylint: enable=C0301

LANGUAGE_MAPPINGS = {
    'dk': {
        'flag': 'ðŸ‡©ðŸ‡°',
    },
    'en': {
        'flag': 'ðŸ‡¬ðŸ‡§',
    },
}
EXPECTED_BOOTSTRAP_FILES = {
    'bootstrap.min.css': '4ffcc598ee6cff4692c1cea272cd8a2f195f6dec32473e94370d6cdcfa5fe601',  # pylint: disable=C0301
    'bootstrap-grid.min.css': '158cf68fff05fa7b67dab1734752e67e4d4dcf08a3bbb3e046d5cd9cbc3bd86b',  # pylint: disable=C0301
    'bootstrap-reboot.min.css': 'cd3d5950dfe3d62fda39a009a26977aeef162d133c4a264ae5812bfb5489c5b8',  # pylint: disable=C0301
}


class Section:  # pylint: disable=R0903
    """A section of a blog post."""
    def __init__(self, section_data: dict):
        _validate_section_data(section_data)
        self.title = escape(section_data['title'])
        self.text = escape(section_data['text'])
        self.language = section_data['language']
        self.flag = LANGUAGE_MAPPINGS[self.language]['flag']

    def get_html(self) -> str:
        """Get this section's HTML."""
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{self.flag}{self.title}</h2>\n'
            f'<p>{self.text}\n'
            '</div>'
        )


class Post:  # pylint: disable=R0903
    """A blog post."""
    def __init__(self, sections: typing.List[Section],
                 html_filename: str,
                 next_path: typing.Optional[str],
                 prev_path: typing.Optional[str]):
        self.sections = sections
        self.html_filename = html_filename
        self.next_path = next_path or '#'
        self.prev_path = prev_path or '#'

    def get_html(self) -> str:
        """Get this post's HTML."""
        return POST_TEMPLATE.format(
            section1=self.sections[0].get_html(),
            section2=self.sections[1].get_html(),
            prev_post=self.prev_path,
            prev_attrs=_get_header_link_attrs(self.prev_path),
            next_post=self.next_path,
            next_attrs=_get_header_link_attrs(self.next_path),
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class InvalidSectionData(Exception):
    """Raised when attempting to generate a section from invalid data."""


def _get_header_link_attrs(target):
    """Get the attributes to assign to a header link based on the target."""
    if target == '#':
        return 'style="cursor:default" class="text-muted navbar-brand"'
    return 'class="navbar-brand"'


def _validate_section_data(section_data: dict):
    """Generate a Section if given valid section data."""
    required_keys = ['title', 'text', 'language']
    all_keys = required_keys

    errors = []

    if (
        any(key not in all_keys for key in section_data)
        or not all(key in section_data for key in required_keys)
    ):
        valid = ','.join(sorted(all_keys))
        req = ','.join(sorted(required_keys))
        contained = ','.join(sorted(section_data))
        errors.append(
            f'The section data may contain the following keys: {valid}\n'
            f'The section data must contain the following keys: {req}\n'
            f'The section contained: {contained}'
        )

    if section_data['language'] not in LANGUAGE_MAPPINGS:
        errors.append(
            'Language was {}, but must be one of: {}'.format(  # pylint: disable=C0209
                section_data['language'],
                ','.join(LANGUAGE_MAPPINGS.keys()),
            )
        )

    if errors:
        raise InvalidSectionData('\n'.join(errors))


class InvalidPostData(Exception):
    """Raised when the data for a post is not as expected."""


def _get_post_data_path(post_file: str, data_dir: str) -> str:
    path = os.path.join(data_dir, post_file)
    return path


def _get_post_html_filename(post_file: str) -> str:
    name = os.path.splitext(post_file)[0]
    return name + '.html'


def load_posts(data_dir: str) -> typing.List[Post]:
    """Load post data from a directory."""
    posts = []
    post_data_files = os.listdir(data_dir)
    for idx, post_file in enumerate(post_data_files):
        post_data_path = _get_post_data_path(post_file, data_dir)
        prev_post = None
        next_post = None
        if idx > 0:
            prev_post = _get_post_html_filename(post_data_files[idx - 1])
        if idx < (len(post_data_files) - 1):
            next_post = _get_post_html_filename(post_data_files[idx + 1])
        with open(post_data_path, encoding='utf-8') as post_handle:
            post_data = json.load(post_handle)
        if len(post_data) != 2:
            raise InvalidPostData(
                f'2 sections were expected in {post_data_path}')
        try:
            posts.append(Post(
                sections=[
                    Section(s)
                    for s in sorted(post_data, key=lambda x: x['language'])
                ],
                next_path=next_post,
                prev_path=prev_post,
                html_filename=_get_post_html_filename(post_file),
            ))
        except InvalidSectionData as err:
            raise InvalidPostData(  # pylint: disable=W0707
                f'Post contained invalid section data: {err}')
    return posts


class InvalidHTMLDir(Exception):
    """Raised when post update cannot be performed."""


def update_posts(posts: typing.List[Post], html_dir: str):
    """Add new posts and update any existing posts that need updating."""

    updated = 0
    for post in posts:
        html_content = post.get_html()
        html_path = post.get_html_path(html_dir)
        current_content = ''
        if os.path.exists(html_path):
            with open(html_path, encoding='utf-8') as html_handle:
                current_content = html_handle.read()
        if current_content == html_content:
            print(f'Post is up to date at: {html_path}')
            continue
        print(f'Updating {html_path}')
        updated += 1
        with open(html_path, 'w', encoding='utf-8') as html_handle:
            html_handle.write(html_content)
    print(f'Updated {updated}/{len(posts)} posts.')


def check_html_dir_valid(html_dir: str):
    """Check that the targeted HTML dir is valid."""
    print('Checking HTML dir exists')
    if not os.path.isdir(html_dir):
        raise InvalidHTMLDir(
            f'HTML destination dir does not exist: {html_dir}')

    print('Validating bootstrap files')
    bootstrap_path = os.path.join(html_dir, 'bootstrap')
    bootstrap_files = {}
    for bs_file in os.listdir(bootstrap_path):
        bs_path = os.path.join(bootstrap_path, bs_file)
        with open(bs_path, 'rb') as bs_handle:
            bootstrap_files[bs_file] = sha256(
                bs_handle.read()).hexdigest()
    if bootstrap_files != EXPECTED_BOOTSTRAP_FILES:
        raise InvalidHTMLDir(
            'Expected bootstrap files not found.\n'  # pylint: disable=C0209
            'Expected to see the following files with listed SHA256 hashes:\n'
            '{expected_output}\n'
            'The following files were seen:\n'
            '{seen_output}'.format(
                expected_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in EXPECTED_BOOTSTRAP_FILES.items()
                ),
                seen_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in bootstrap_files.items()
                ),
            )
        )


if __name__ == '__main__':
    SOURCE_DIR = 'test_posts'
    DEST_DIR = 'test_html'
    posts_data = load_posts(SOURCE_DIR)
    check_html_dir_valid(DEST_DIR)
    update_posts(posts_data, DEST_DIR)
