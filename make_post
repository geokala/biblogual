#! /usr/bin/env python3
"""Generate pages for a static blog."""
from datetime import datetime
from hashlib import sha256
from html import escape
import json
import os
import subprocess
from tempfile import mkdtemp
import typing
from typing_extensions import TypedDict

# TODO: BLOG TITLE needs to have the actual title set from somewhere...
DISABLED_NAVBAR_LINK_ATTRS = \
    'style="cursor:default" class="text-muted navbar-brand"'
# pylint: disable=C0301
POST_TEMPLATE = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BLOG TITLE</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{first_post}" class="navbar-brand"><strong>FIRST POST</strong></a>
<a id="prev-link" href="{prev_post}" {prev_attrs}><strong>PREVIOUS POST</strong></a>
<a id="next-link" href="{next_post}" {next_attrs}><strong>NEXT POST</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>LATEST POST</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>HOMEPAGE</strong></a>
</div>
<div class="container-fluid clearfix">
{section1}
{section2}
</div>
</body>
</html>'''
INDEX_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BLOG TITLE</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>FIRST POST</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>PREVIOUS POST</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>NEXT POST</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>LATEST POST</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>HOMEPAGE</strong></a>
</div>
<div class="container-fluid clearfix">
{{year_links}}
</div>
</body>
</html>'''
YEAR_TEMPLATE = f'''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>BLOG TITLE - {{year}}</title>
<link rel="stylesheet" type="text/css" href="./bootstrap/bootstrap.min.css">
</head>
<body>
<div class="navbar navbar-dark bg-dark">
<a id="first-link" href="{{first_post}}" class="navbar-brand"><strong>FIRST POST</strong></a>
<a id="prev-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>PREVIOUS POST</strong></a>
<a id="next-link" href="#" {DISABLED_NAVBAR_LINK_ATTRS}><strong>NEXT POST</strong></a>
<a id="latest-link" href="latest.html" class="navbar-brand"><strong>LATEST POST</strong></a>
<a id="home-link" href="index.html" class="navbar-brand"><strong>HOMEPAGE</strong></a>
</div>
<div class="container-fluid clearfix">
{{post_links1}}
{{post_links2}}
</div>
</body>
</html>'''
# pylint: enable=C0301

DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'
LANGUAGE_MAPPINGS = {
    'dk': {
        'name': 'Dansk',
        'flag': '🇩🇰',
        'mood': 'Humør',
        'posts': 'Blogindlæg',
        'title_placeholder': 'Skriv title her',
        'text_placeholder': 'Skriv blogtekst her og nedenfor',
    },
    'en': {
        'name': 'English',
        'flag': '🇬🇧',
        'mood': 'Mood',
        'posts': 'Blog posts',
        'title_placeholder': 'Write title here',
        'text_placeholder': 'Write blog text here and below',
    },
}
MONTH_MAPPINGS = {
    'dk': {
        1: 'Jan',
        2: 'Feb',
        3: 'Mar',
        4: 'Apr',
        5: 'Maj',
        6: 'Jun',
        7: 'Jul',
        8: 'Aug',
        9: 'Sep',
        10: 'Okt',
        11: 'Nov',
        12: 'Dec',
    },
    'en': {
        1: 'Jan',
        2: 'Feb',
        3: 'Mar',
        4: 'Apr',
        5: 'May',
        6: 'Jun',
        7: 'Jul',
        8: 'Aug',
        9: 'Sep',
        10: 'Oct',
        11: 'Nov',
        12: 'Dec',
    },
}
MOOD_NAME_MAPPINGS = {
    'dk': {
        'glad': 'happy',
        'trist': 'sad',
        'betænksom': 'thoughtful',
        'gnaven': 'grumpy',
    },
    'en': {
        'happy': 'happy',
        'sad': 'sad',
        'thoughtful': 'thoughtful',
        'grumpy': 'grumpy',
    },
}
MOOD_EMOJI_MAPPINGS = {
    'happy': '🙂',
    'sad': '🙁',
    'thoughtful': '🤔',
    'grumpy': '😠',
}
EXPECTED_BOOTSTRAP_FILES = {
    'bootstrap.min.css': '4ffcc598ee6cff4692c1cea272cd8a2f195f6dec32473e94370d6cdcfa5fe601',  # pylint: disable=C0301
    'bootstrap-grid.min.css': '158cf68fff05fa7b67dab1734752e67e4d4dcf08a3bbb3e046d5cd9cbc3bd86b',  # pylint: disable=C0301
    'bootstrap-reboot.min.css': 'cd3d5950dfe3d62fda39a009a26977aeef162d133c4a264ae5812bfb5489c5b8',  # pylint: disable=C0301
}


class Section:  # pylint: disable=R0903
    """A section of a blog post."""
    def __init__(self,
                 section_data: dict,
                 date: datetime,
                 link_urls: typing.Optional[typing.List[str]]):
        _validate_section_data(section_data)
        self.title = escape(section_data['title'])
        self.text = escape(section_data['text'])
        self.mood = escape(section_data.get('mood', ''))
        self.language = section_data['language']
        self.flag = LANGUAGE_MAPPINGS[self.language]['flag']
        self.date = _get_date_string(date, self.language)
        self.links = []
        if link_urls:
            link_descriptions = [
                escape(desc) for desc in section_data.get('links', [])]
            if len(link_urls) != len(link_descriptions):
                raise InvalidSectionData(
                    'Sections must have as many link descriptions as there '
                    'are link urls.\n'
                    f'Link descriptions: {link_descriptions}'
                    f'Link urls: {link_urls}'
                )
            self.links = list(zip(link_urls, link_descriptions))

    def get_html(self) -> str:
        """Get this section's HTML."""
        mood_string = ''
        if self.mood:
            mood = LANGUAGE_MAPPINGS[self.language]['mood']
            mood_emoji_name_mapping = MOOD_NAME_MAPPINGS[self.language].get(
                self.mood)
            emoji = ''
            if mood_emoji_name_mapping:
                emoji = MOOD_EMOJI_MAPPINGS[mood_emoji_name_mapping] + ' '
            mood_string = f'<small>{mood}: {emoji}{self.mood}</small>\n'
        if self.links:
            links_text = '\n'.join(['Links:<br />'] + [
                f'<a href="{link}">{description}</a><br />'
                for link, description in self.links
            ] + ['<br />'])
        else:
            links_text = ''
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{self.flag}{self.title}</h2>\n'
            f'{mood_string}'
            f'<p>{self.text}</p>\n'
            f'{links_text}'
            f'<small>{self.date}</small>\n'
            '</div>'
        )


class Post:  # pylint: disable=R0903
    """A blog post."""
    def __init__(self,  # pylint: disable=R0913
                 sections: typing.List[Section],
                 html_filename: str,
                 date: datetime,
                 first_path: str,
                 next_path: typing.Optional[str],
                 prev_path: typing.Optional[str]):
        self.sections = sections
        self.html_filename = html_filename
        self.first_path = first_path
        self.next_path = next_path or '#'
        self.prev_path = prev_path or '#'
        self.date = date

    def get_html(self) -> str:
        """Get this post's HTML."""
        return POST_TEMPLATE.format(
            section1=self.sections[0].get_html(),
            section2=self.sections[1].get_html(),
            first_post=self.first_path,
            prev_post=self.prev_path,
            prev_attrs=_get_header_link_attrs(self.prev_path),
            next_post=self.next_path,
            next_attrs=_get_header_link_attrs(self.next_path),
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Year:
    """An overview of a year of blog posts."""
    def __init__(self, year: int, posts: typing.List[Post]):
        self.year = year
        self.posts = posts
        self.html_filename = f'year_{self.year}.html'
        self.languages = sorted([
            section.language for section in posts[0].sections
        ])

    def get_html(self) -> str:
        """Get this year's HTML."""
        return YEAR_TEMPLATE.format(
            year=self.year,
            first_post=self.posts[0].html_filename,
            post_links1=self._get_post_links_html(self.languages[0]),
            post_links2=self._get_post_links_html(self.languages[1]),
        )

    def _get_post_links_html(self, language: str):
        """Get the HTML for the given language for this year."""
        months_html = [
            self._get_section_month_html(month, language)
            for month in range(1,13)
        ]
        months_html_string = '\n'.join([
            month_html for month_html in months_html if month_html
        ])
        posts_title = LANGUAGE_MAPPINGS[language]['posts']
        flag = LANGUAGE_MAPPINGS[language]['flag']
        return (
            '<div class="ml-5 float-md-left">\n'
            f'<h2>{flag}{posts_title}</h2>\n'
            f'{months_html_string}\n'
            '</div>\n'
        )

    def _get_section_month_html(self, month: int, language: str):
        """Get the section HTML for a given month and language."""
        relevant_posts = [post
                          for post in self.posts if post.date.month == month]
        month_html = []
        if relevant_posts:
            month_string = MONTH_MAPPINGS[language][month]
            month_html.append(f'<h3>{month_string}</h3>')
        dates_and_titles = {}
        for post in relevant_posts:
            for section in post.sections:
                if section.language == language:
                    dates_and_titles[post.date] = (section.title, post)
                    break
        for date in sorted(dates_and_titles):
            title, post = dates_and_titles[date]
            date_string = _get_date_string(post.date, language)
            month_html.append(
                f'<a href="{post.html_filename}">{date_string} - {title}'
                '</a><br />')
        return '\n'.join(month_html)

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for this post in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class Index:
    """The top level index."""
    def __init__(self, years: typing.List[Year], first_path: str):
        self.first_path = first_path
        self.years = years
        self.html_filename = 'index.html'

    def _get_year_links_html(self):
        """Get the links for each year of blog posts."""
        return '\n'.join([
            f'<a href="{year.html_filename}">{year.year}</a>'
            for year in self.years
        ])

    def get_html(self) -> str:
        """Get the index HTML."""
        return INDEX_TEMPLATE.format(
            first_post=self.first_path,
            year_links=self._get_year_links_html(),
        )

    def get_html_path(self, html_dir: str) -> str:
        """Get the desired html path for the index in the given dir."""
        return os.path.join(html_dir, self.html_filename)


class InvalidSectionData(Exception):
    """Raised when attempting to generate a section from invalid data."""


class SectionData(TypedDict):
    """The dict structure of a section as contained in the json file."""
    title: str
    links: typing.List[str]
    text: str
    language: str
    mood: typing.Optional[str]


class PostData(TypedDict):
    """The dict structure of post data as contained in the json files."""
    date: str
    links: typing.List[str]
    sections: typing.List[SectionData]


def _get_date_string(date: datetime, language: str):
    """Get the stringified date for the given language."""
    month = MONTH_MAPPINGS[language][date.month]
    return f'{date.year} {month} {date.day}'


def _get_header_link_attrs(target):
    """Get the attributes to assign to a header link based on the target."""
    if target == '#':
        return DISABLED_NAVBAR_LINK_ATTRS
    return 'class="navbar-brand"'


def _validate_section_data(section_data: dict):
    """Generate a Section if given valid section data."""
    required_keys = ['title', 'text', 'language']
    optional_keys = ['mood', 'links']
    all_keys = required_keys + optional_keys

    errors = []

    if (
        any(key not in all_keys for key in section_data)
        or not all(key in section_data for key in required_keys)
    ):
        valid = ','.join(sorted(all_keys))
        req = ','.join(sorted(required_keys))
        contained = ','.join(sorted(section_data))
        errors.append(
            f'The section data may contain the following keys: {valid}\n'
            f'The section data must contain the following keys: {req}\n'
            f'The section contained: {contained}'
        )

    if section_data['language'] not in LANGUAGE_MAPPINGS:
        errors.append(
            'Language was {}, but must be one of: {}'.format(  # pylint: disable=C0209
                section_data['language'],
                ','.join(LANGUAGE_MAPPINGS.keys()),
            )
        )

    if errors:
        raise InvalidSectionData('\n'.join(errors))


class InvalidPostData(Exception):
    """Raised when the data for a post is not as expected."""


def _get_post_data_path(post_file: str, data_dir: str) -> str:
    path = os.path.join(data_dir, post_file)
    return path


def _get_post_html_filename(post_file: str) -> str:
    name = os.path.splitext(post_file)[0]
    return name + '.html'


def load_posts(data_dir: str) -> typing.List[Post]:
    """Load post data from a directory."""
    posts = []
    post_data_files = os.listdir(data_dir)
    first_post = _get_post_html_filename(post_data_files[0])
    for idx, post_file in enumerate(post_data_files):
        post_data_path = _get_post_data_path(post_file, data_dir)
        prev_post = None
        next_post = None
        if idx > 0:
            prev_post = _get_post_html_filename(post_data_files[idx - 1])
        if idx < (len(post_data_files) - 1):
            next_post = _get_post_html_filename(post_data_files[idx + 1])
        with open(post_data_path, encoding='utf-8') as post_handle:
            post_data = json.load(post_handle)
        date = datetime.strptime(post_data['date'], DATETIME_FORMAT)
        if len(post_data['sections']) != 2:
            raise InvalidPostData(
                f'2 sections were expected in {post_data_path}')
        try:
            posts.append(Post(
                sections=[
                    Section(s,
                            date=date,
                            link_urls=post_data.get('links'))
                    for s in sorted(post_data['sections'],
                                    key=lambda x: x['language'])
                ],
                first_path=first_post,
                next_path=next_post,
                prev_path=prev_post,
                html_filename=_get_post_html_filename(post_file),
                date=date,
            ))
        except InvalidSectionData as err:
            raise InvalidPostData(  # pylint: disable=W0707
                f'Post contained invalid section data: {err}')
    return posts


class InvalidHTMLDir(Exception):
    """Raised when post update cannot be performed."""


def update_file_if_needed(expected_content: str, path: str):
    """Update a file if the contents should be changed.
    Returns True if updated, False if not.
    """
    current_content = None
    if os.path.exists(path):
        with open(path, encoding='utf-8') as handle:
            current_content = handle.read()
    if current_content == expected_content:
        print(f'{path} is up to date.')
        return False
    print(f'Updating {path}')
    with open(path, 'w', encoding='utf-8') as handle:
        handle.write(expected_content)
    return True


def build_years_pages(posts: typing.List[Post]) -> typing.List[Year]:
    """Build the Year pages."""
    year_posts: typing.Dict[int, typing.List[Post]] = {}
    for post in posts:
        year = post.date.year
        if year not in year_posts:
            year_posts[year]= []
        year_posts[year].append(post)
    return [Year(year=year, posts=posts)
            for year, posts in year_posts.items()]


def update_posts(posts: typing.List[Post], html_dir: str):
    """Add new posts and update any existing posts that need updating."""

    updated = 0
    for post in posts:
        html_content = post.get_html()
        html_path = post.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated += 1
    if updated:
        print(f'Updated {updated}/{len(posts)} posts.')

    if update_file_if_needed(
        posts[-1].get_html(),
        os.path.join(html_dir, 'latest.html'),
    ):
        print('Updated latest post.')

    updated_years = 0
    years = build_years_pages(posts)
    for year in years:
        html_content = year.get_html()
        html_path = year.get_html_path(html_dir)
        if update_file_if_needed(html_content, html_path):
            updated_years += 1
    if updated_years:
        print(f'Updated {updated_years}/{len(years)} year pages.')

    index = Index(years, first_path=posts[0].html_filename)
    if update_file_if_needed(index.get_html(), index.get_html_path(html_dir)):
        print('Updated index.')


def check_html_dir_valid(html_dir: str):
    """Check that the targeted HTML dir is valid."""
    print('Checking HTML dir exists')
    if not os.path.isdir(html_dir):
        raise InvalidHTMLDir(
            f'HTML destination dir does not exist: {html_dir}')

    print('Validating bootstrap files')
    bootstrap_path = os.path.join(html_dir, 'bootstrap')
    bootstrap_files = {}
    for bs_file in os.listdir(bootstrap_path):
        bs_path = os.path.join(bootstrap_path, bs_file)
        with open(bs_path, 'rb') as bs_handle:
            bootstrap_files[bs_file] = sha256(
                bs_handle.read()).hexdigest()
    if bootstrap_files != EXPECTED_BOOTSTRAP_FILES:
        raise InvalidHTMLDir(
            'Expected bootstrap files not found.\n'  # pylint: disable=C0209
            'Expected to see the following files with listed SHA256 hashes:\n'
            '{expected_output}\n'
            'The following files were seen:\n'
            '{seen_output}'.format(
                expected_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in EXPECTED_BOOTSTRAP_FILES.items()
                ),
                seen_output='\n'.join(
                    ' '.join(fn_hash)
                    for fn_hash in bootstrap_files.items()
                ),
            )
        )


def get_user_confirmation(message='Are these correct? (y/n): ') -> bool:
    """Prompt the user to see if something is correct."""
    while True:
        confirm = input(message).strip().lower()
        if confirm == 'y':
            return True
        if confirm == 'n':
            return False
        print(f'{confirm} is not a valid response.')


def get_links() -> typing.List[typing.Dict[str, str]]:
    """Get links to add to the post, if any."""
    links: typing.List[typing.Dict[str, str]] = []
    add_prompt = 'Would you like to add a link? (y/n): '
    while True:
        if not get_user_confirmation(add_prompt):
            return links

        link = {}
        link['url'] = input('Enter link URL: ').strip()

        for lang in sorted(LANGUAGE_MAPPINGS):
            lang_name = LANGUAGE_MAPPINGS[lang]['name']
            link[lang] = input(
                f'Enter {lang_name} description for this URL: ')

        if get_user_confirmation('Is this URL correct? (y/n): '):
            links.append(link)


def get_custom_mood() -> typing.Tuple[str, str]:
    """Prompt the user for a custom mood."""
    moods = {lang: '' for lang in LANGUAGE_MAPPINGS}
    while any(not mood for mood in moods.values()):
        for lang in sorted(moods):
            lang_name = LANGUAGE_MAPPINGS[lang]['name']
            moods[lang] = input(f'Enter {lang_name} mood:').strip()
        if get_user_confirmation():
            moods = {lang: '' for lang in LANGUAGE_MAPPINGS}
    order = sorted(moods.keys())
    return moods[order[0]], moods[order[1]]


def get_mood() -> typing.Tuple[str, str]:
    """Prompt the user to get their mood."""
    moods = sorted(
        MOOD_NAME_MAPPINGS['dk'].items(),
        key=lambda x: x[0],
    )

    display_template = '{num}: {lang1} / {lang2}'

    selection = 0
    print('Select mood:')
    for num, mood in enumerate(moods):
        print(display_template.format(num, mood[0], mood[1]))
        print('{}: Custom'.format(len(moods)))  # pylint: disable=C0209
    while not selection:
        try:
            selection = int(input('Select mood: '))
        except ValueError:
            selection = 0

        if selection < 1 or selection > len(moods):
            selection = 0
        else:
            if selection == len(moods):
                return get_custom_mood()
    return moods[selection - 1]


def get_initial_section_data(tempdir: str) -> typing.List[SectionData]:
    """Get the text of the post sections from the user."""
    lang_paths = [
        os.path.join(tempdir, lang)
        for lang in sorted(LANGUAGE_MAPPINGS)
    ]
    file1, file2 = lang_paths

    for lang_file in lang_paths:
        lang_text = LANGUAGE_MAPPINGS[lang_file.split('/')[-1]]
        with open(lang_file, 'w', encoding='utf-8') as handle:
            handle.writelines([
                lang_text['title_placeholder'],
                lang_text['text_placeholder'],
            ])
    subprocess.call(f"vim {file1} -S <(echo 'vs {file2}')")

    sections: typing.List[SectionData] = [
        {
            'title': '',
            'links': [],
            'text': '',
            'language': lang,
            'mood': None,
        }
        for lang in sorted(LANGUAGE_MAPPINGS)
    ]

    for idx, lang_file in enumerate(lang_paths):
        lang = lang_file.split('/')[-1]
        with open(lang_file, 'r', encoding='utf-8') as handle:
            lang_content = handle.readlines()
        if sections[idx]['language'] != lang:
            raise RuntimeError(
                'Section language mismatch- this should never happen.'
            )
        sections[idx]['title'] = lang_content[0]
        sections[idx]['text'] = '\n'.join(lang_content[1:])
    return sections


def make_post(posts_path: str):
    """Make a new post"""
    new_post: PostData = {
        'date': datetime.now().strftime(DATETIME_FORMAT),
        'links': [],
        'sections': [],
    }

    tempdir = mkdtemp(prefix='blogpost')

    try:
        new_post['sections'] = get_initial_section_data(tempdir)
    finally:
        for temp_lang in os.listdir(tempdir):
            temp_lang_path = os.path.join(tempdir, temp_lang)
            os.unlink(temp_lang_path)
        os.rmdir(tempdir)

    mood = get_mood()
    new_post['sections'][0]['mood'] = mood[0]
    new_post['sections'][1]['mood'] = mood[1]

    links = get_links()
    for link in links:
        new_post['links'].append(link['url'])
        for section in new_post['sections']:
            section['links'].append(link[section['language']])

    date = new_post['date']
    post_num = 0
    suffix = 'json'
    post_file = f'{date}-{post_num}.{suffix}'
    while os.path.exists(post_file):
        post_num += 1
        post_file = f'{date}-{post_num}.{suffix}'

    with open(os.path.join(posts_path, post_file), 'w',
              encoding='utf-8') as post_handle:
        json.dump(new_post, post_handle)


if __name__ == '__main__':
    SOURCE_DIR = 'test_posts'
    DEST_DIR = 'test_html'
    posts_data = load_posts(SOURCE_DIR)
    check_html_dir_valid(DEST_DIR)
    update_posts(posts_data, DEST_DIR)
